first_grid <- add_pattern(matrice, grid_data, 25, 25)
grid_data <- first_grid
grid_data <- update_grid(grid_data)
library(dplyr)
library(ggplot2)
library(plotly)
####################################################################
size <- 3
# Calcul du nombre total de combinaisons
num_combinations <- 2^(size^2)
# Génération de toutes les combinaisons possibles de 0 et 1
combinations <- expand.grid(rep(list(0:1), size^2))
matrice <- matrix(as.vector(t(combinations[500,])), nrow = size, byrow = TRUE)
generate_grid <- function(n) {
matrix(0, n, n)
}
add_pattern <- function(pattern, grid, x, y) {
grid[x:(x+ncol(pattern)-1), y:(y+nrow(pattern)-1)] <- t(pattern)
grid
}
update_grid <- function(grid) {
n <- nrow(grid)
new_grid <- grid
for (i in 1:n) {
for (j in 1:n) {
neighbors <- sum(grid[max(1, i-1):min(n, i+1), max(1, j-1):min(n, j+1)]) - grid[i, j]
if (grid[i, j] == 1 && (neighbors < 2 || neighbors > 3)) {
new_grid[i, j] <- 0
} else if (grid[i, j] == 0 && neighbors == 3) {
new_grid[i, j] <- 1
}
}
}
new_grid
}
first_grid <- add_pattern(matrice, grid_data, 25, 25)
grid <- generate_grid(50)
grid_data <- grid
first_grid <- add_pattern(matrice, grid_data, 25, 25)
grid_data <- first_grid
grid_data <- update_grid(grid_data)
n = 1
while (!isTRUE(all.equal(grid_data, first_grid)) && !all(grid_data == 0) && n < 10) {
grid_data <- update_grid(grid_data)
n <- n + 1
}
n
matrice <- matrix(c(0, 1, 0,
0, 1, 0,
0, 1, 0), nrow = 3, byrow = TRUE)
first_grid <- add_pattern(matrice, grid_data, 25, 25)
grid_data <- first_grid
grid_data <- update_grid(grid_data)
n = 1
while (!isTRUE(all.equal(grid_data, first_grid)) && !all(grid_data == 0) && n < 10) {
grid_data <- update_grid(grid_data)
n <- n + 1
}
n
matrice
first_grid <- add_pattern(matrice, grid_data, 25, 25)
grid_data <- first_grid
matrix(as.vector(t(combinations)), nrow = 3, byrow = TRUE)
library(dplyr)
library(ggplot2)
library(plotly)
size <- 3
num_combinations <- 2^(size^2)
combinations <- expand.grid(rep(list(0:1), size^2))
matrix(as.vector(t(combinations)), nrow = 3, byrow = TRUE)
df_matrice <- matrix(as.vector(t(combinations)), nrow = 3, byrow = TRUE)
View(df_matrice)
matrix(as.vector(t(combinations[1, ])), nrow = 3, byrow = TRUE)
# Générer toutes les combinaisons possibles pour une matrice 3x3
size <- 3
num_combinations <- 2^(size^2)
combinations <- expand.grid(rep(list(0:1), size^2))
# Convertir chaque combinaison en matrice et les stocker dans une colonne du DataFrame
results <- data.frame(matrice = I(apply(combinations, 1, function(x) list(matrix(x, nrow = size, byrow = TRUE)))),
type = character(num_combinations),
n = integer(num_combinations),
stringsAsFactors = FALSE)
View(results)
View(results[[1]][[1]])
results[[1]][[1]][[1]]
results$matrice[1]
n = 1
max_iterations = 10
####################################################################
library(dplyr)
# Fonction pour vérifier si une matrice est contenue dans une autre
contains_matrix <- function(grid, pattern) {
grid_rows <- nrow(grid)
grid_cols <- ncol(grid)
pattern_rows <- nrow(pattern)
pattern_cols <- ncol(pattern)
for (i in 1:(grid_rows - pattern_rows + 1)) {
for (j in 1:(grid_cols - pattern_cols + 1)) {
sub_grid <- grid[i:(i + pattern_rows - 1), j:(j + pattern_cols - 1)]
if (all(sub_grid == pattern)) {
return(TRUE)
}
}
}
return(FALSE)
}
# Initialiser le grid et la matrice de recherche
matrice <- matrix(c(0, 0, 0,
0, 1, 0,
0, 1, 0), nrow = 3, byrow = TRUE)
first_grid <- add_pattern(matrice, grid, 25, 25)
# Générer toutes les combinaisons possibles pour une matrice 3x3
size <- 3
num_combinations <- 2^(size^2)
combinations <- expand.grid(rep(list(0:1), size^2))
# Convertir chaque combinaison en matrice et les stocker dans une colonne du DataFrame
results <- data.frame(matrice = I(apply(combinations, 1, function(x) list(matrix(x, nrow = size, byrow = TRUE)))),
type = character(num_combinations),
n = integer(num_combinations),
stringsAsFactors = FALSE)
generate_grid <- function(n) {
matrix(0, n, n)
}
grid <- generate_grid(50)
grid_data <- grid
add_pattern <- function(pattern, grid, x, y) {
grid[x:(x+ncol(pattern)-1), y:(y+nrow(pattern)-1)] <- t(pattern)
grid
}
update_grid <- function(grid) {
n <- nrow(grid)
new_grid <- grid
for (i in 1:n) {
for (j in 1:n) {
neighbors <- sum(grid[max(1, i-1):min(n, i+1), max(1, j-1):min(n, j+1)]) - grid[i, j]
if (grid[i, j] == 1 && (neighbors < 2 || neighbors > 3)) {
new_grid[i, j] <- 0
} else if (grid[i, j] == 0 && neighbors == 3) {
new_grid[i, j] <- 1
}
}
}
new_grid
}
# Boucle principale pour chaque matrice dans 'results'
for (i in seq_len(nrow(results))) {
grid_data <- update_grid(first_grid)
n <- 1
max_iterations <- 10
type <- 'st'
while (n < max_iterations) {
grid_data <- update_grid(grid_data)
n <- n + 1
# Condition 1: grid_data == first_grid
if (isTRUE(all.equal(grid_data, first_grid))) {
type <- 'osc'
break
}
# Condition 2: all(grid_data == 0)
if (all(grid_data == 0)) {
type <- 'null'
break
}
# Condition 3: contains_matrix(grid_data, matrice)
if (contains_matrix(grid_data, matrice)) {
type <- 'spaceships'
break
}
}
# Mettre à jour les résultats
results$type[i] <- type
results$n[i] <- n
}
library(dplyr)
# Fonction pour vérifier si une matrice est contenue dans une autre
contains_matrix <- function(grid, pattern) {
grid_rows <- nrow(grid)
grid_cols <- ncol(grid)
pattern_rows <- nrow(pattern)
pattern_cols <- ncol(pattern)
for (i in 1:(grid_rows - pattern_rows + 1)) {
for (j in 1:(grid_cols - pattern_cols + 1)) {
sub_grid <- grid[i:(i + pattern_rows - 1), j:(j + pattern_cols - 1)]
if (all(sub_grid == pattern)) {
return(TRUE)
}
}
}
return(FALSE)
}
# Initialiser le grid et la matrice de recherche
first_grid <- add_pattern(matrix(c(0, 0, 0, 0, 1, 0, 0, 1, 0), nrow = 3, byrow = TRUE), grid, 25, 25)
# Générer toutes les combinaisons possibles pour une matrice 3x3
size <- 3
num_combinations <- 2^(size^2)
combinations <- expand.grid(rep(list(0:1), size^2))
# Convertir chaque combinaison en matrice et les stocker dans une colonne du DataFrame
results <- data.frame(matrice = I(apply(combinations, 1, function(x) list(matrix(x, nrow = size, byrow = TRUE)))),
type = character(num_combinations),
n = integer(num_combinations),
stringsAsFactors = FALSE)
# Boucle principale pour chaque matrice dans 'results'
for (i in seq_len(nrow(results))) {
grid_data <- results$matrice[[i]]
n <- 1
max_iterations <- 10
type <- 'st'
while (n <= max_iterations) {
grid_data <- update_grid(grid_data)
# Condition 1: grid_data == first_grid
if (isTRUE(all.equal(grid_data, first_grid))) {
type <- 'osc'
break
}
# Condition 2: all(grid_data == 0)
if (all(grid_data == 0)) {
type <- 'null'
break
}
# Condition 3: contains_matrix(grid_data, matrice)
if (contains_matrix(grid_data, matrix(c(0, 0, 0, 0, 1, 0, 0, 1, 0), nrow = 3, byrow = TRUE))) {
type <- 'spaceships'
break
}
n <- n + 1
}
# Mettre à jour les résultats
results$type[i] <- type
results$n[i] <- n
}
# Afficher les résultats
print(results)
# Boucle principale pour chaque matrice dans 'results'
for (i in seq_len(nrow(results))) {
grid_data <- results$matrice[[i]]
n <- 1
max_iterations <- 10
type <- 'st'
while (n <= max_iterations) {
grid_data <- update_grid(grid_data)
# Condition 1: grid_data == first_grid
if (isTRUE(all.equal(grid_data, first_grid))) {
type <- 'osc'
break
}
# Condition 2: all(grid_data == 0)
if (all(grid_data == 0)) {
type <- 'null'
break
}
# Condition 3: contains_matrix(grid_data, matrice)
if (contains_matrix(grid_data, matrix(c(0, 0, 0, 0, 1, 0, 0, 1, 0), nrow = 3, byrow = TRUE))) {
type <- 'spaceships'
break
}
n <- n + 1
}
# Mettre à jour les résultats
results$type[i] <- type
results$n[i] <- n
}
grid_data <- add_pattern(matrix(results$matrice[[i]], nrow = 3, byrow = TRUE), grid, 25, 25)
i
grid_data
plot_ly(
z = t(grid_data[nrow(grid_data):1, ]),
type = "heatmap",
colors = c("white", "black"),
showscale = FALSE
) %>% layout(
xaxis = list(showticklabels = FALSE, showline = FALSE, title = ""),
yaxis = list(showticklabels = FALSE, showline = FALSE, title = "")
)
